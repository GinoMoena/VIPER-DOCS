[{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"Component","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Component","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Component","url":"/VIPER-DOCS/docs/ECS/Component#atributos","content":"bool Active true by default​ Permite saber si el componente está activo, esto puede ser utilizado por cualquier sistema y puede aplicar a cualquier componente por eso se ha creado como una propiedad que será heredada por cualquier componente que lo necesite. "},{"title":"Métodos​","type":1,"pageTitle":"Component","url":"/VIPER-DOCS/docs/ECS/Component#métodos","content":"Dada la lógica de la arquitectura ECS, el componente no puede tener métodos, solo data. En caso de necesitar crear un método para un componente la solución siempre será crear un sistema en su lugar que transforme el estado del componente. "},{"title":"Command","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Components/Command","content":"","keywords":""},{"title":"Métodos​","type":1,"pageTitle":"Command","url":"/VIPER-DOCS/docs/ECS/Components/Command#métodos","content":"execute(Object obj) virtual void​ Este es un método vacío, luego las clases que necesiten realizar acciones deberán hederar estas clase reimplementando este método para realizar las tareas que necesiten. En el caso de Físicas ya se creó la acción salto y la categoría de PhysicsCommand que extiende de Command, por lo que si es necesario realizar una acción relativa a fisicas lo mejor será heredar directo de PhysicsCommand en lugar de Command ya que tiene un método execute que recibe como parámetro un MovePhysics. "},{"title":"Transform","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Components/Transform","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Transform","url":"/VIPER-DOCS/docs/ECS/Components/Transform#atributos","content":"Vector2 Position​ Indica la posición X,Y de la entidad en el espacio. Por defecto es (0, 0) Quaternion Rotation​ Indica la rotación aplicada a la posición en relación al espacio. Por defecto es 0. `Vector2 Scale​ Indica el tamaño de la entidad en relación al espacio. Por defecto es (1,1). bool FlipX​ Indica si la entidad está volteada en el eje horizontal. bool FlipY​ Indica si la entidad está volteada en el eje vertical. "},{"title":"Entity","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Entity","content":"Entity Las entidades en el ECS del engine son simplemente un entero, por lo que no tienen representación a través de una clase. Hay una utilidad que permite facilitar el acceso a componentes de una entidad, para más información revisar la sección EntityManager.","keywords":""},{"title":"EntityManager","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Components/EntityManager","content":"","keywords":""},{"title":"EntityManager​","type":1,"pageTitle":"EntityManager","url":"/VIPER-DOCS/docs/ECS/Components/EntityManager#entitymanager","content":"clase estática que contiene utilidades (debería llamarse EntityUtils no ?) para obtener componentes en entidades o agregar componentes a entidades. "},{"title":"Métodos​","type":1,"pageTitle":"EntityManager","url":"/VIPER-DOCS/docs/ECS/Components/EntityManager#métodos","content":"void AddComponentToEntity (Component component, int entity)​ Atajo para GameScene.AddComponent. Permite agregar el componente component a la entidad entity bool HasComponent&lt;T&gt;(int entity)​ Atajo para GameScene.HasComponent. Permite saber si la entidad entity contiene el component T. int CreateEntity()​ Atajo para GameScene.CreateEntity. Permite declarar una nueva entidad. "},{"title":"TagComponent","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Components/TagComponent","content":"TagComponent Componente que permite agregar un tag a una entidad. Parecido a los tags de Unity. Dentro del archivo hay un enum de tipo Tag que contiene las definiciones de Tag por default, se pueden agregar más en caso de que sea necesario. Atributos​ Tag tag​ el tag del componente.","keywords":""},{"title":"CommandBuffer","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Components/CommandBuffer","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"CommandBuffer","url":"/VIPER-DOCS/docs/ECS/Components/CommandBuffer#atributos","content":"BufferSize​ Indica el tamaño del buffer de acciones, mientras mayor sea el tamaño más será el espacio de acciones a guardar. Por ejemplo si es el tamaño es de 60 acciones realizadas un segundo antes de lo posible se ejecutarán, lo que puede resultar en un comportamiento involuntario por lo que se recomienda que el tamaño del buffer sea entre 5 a 15 frames. "},{"title":"Métodos​","type":1,"pageTitle":"CommandBuffer","url":"/VIPER-DOCS/docs/ECS/Components/CommandBuffer#métodos","content":"Update()​ El método update actualiza la cola ingresando continuamente nuevos comandos vacíos, en caso de que la cola supere el tamaño máximo se quitará el elemento más antiguo de la cola para que pueda ingresar uno nuevo. Este proceso es importante ya que si no se limpian comandos antiguos con el tiempo se pueden producir acciones involuntarias GetCommand() T​ Retorna un comando del tipo T si es que existe. Esto es útil si se necesita implementar otro tipo de comando por ejemplo PhysicsCommand donde al ejecutar este tipo de comando se pasa por parámetro un objeto de tipo MovePhysics. Este es un método recursivo que retornará la acción si es que existe pasando eliminando todo lo que este en prioridad a esta acción. En caso de que no exista la acción retornará una nulo. Contains (Type type) bool​ Retorna verdadero si el tipo de comando está contenido en la cola, es útil para echar un vistazo antes de obtener un comando para asegurar de que exista y no retorne un nulo. Enqueue (Command command) void​ Agrega un valor a la cola, aunque el método update se encarga de agregar valores por si solo este método es útil para agregar nuevos comandos. Idealmente se deberá usar cuando el usuario presione un botón para realizar una acción, en luagr de realizar la acción directamente se ingresa a esta cola de comandos. "},{"title":"GameScene","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/Scene","content":"","keywords":""},{"title":"Métodos​","type":1,"pageTitle":"GameScene","url":"/VIPER-DOCS/docs/ECS/Scene#métodos","content":"int CreateEntity (bool addTransform=false)​ Crea una entidad y devuelve el id de la entidad. En esencia las entidades son simplemente un id, cualquier parámetro que se necesite agregar a la entidad se transforma en un componente. void AddComponent(int entity, Component component)​ Agrega el componente component a la entidad entity. Bag&lt;int&gt; GetEntitiesWithComponent&lt;T&gt; where T : Component​ Retorna una lista no ordenada de tipo int con las entidades que contienen un componente de tipo T. Es útil para sistemas que necesitan actualizar cierto tipo de componente y solo necesitan las entidades que utilicen ese componente. void RemoveComponent&lt;T&gt;(int entity) where T : Component​ Remueve el componente de tipo T en la entidad entity void HasComponent&lt;T&gt;(int entity) where T : Component​ Permite saber si la entidad entity tiene el componente T. void HasSystem&lt;T&gt;() where T : GameSystem​ Permite saber si el sistema tiene inicializado algún tipo de sistema. Por ahora no se ha utilizado pero podría ser útil si se necesita agregar o quitar sistemas dinamicamente. void DeleteEntity(int entity)​ Permite eliminar la entidad entity T GetComponent&lt;T&gt;(int entity) where T : Component​ Permite acceder al componente de una entidad, es bastante útil y se utiliza frecuentemente en los sistemas para actualizar los componentes de entidades. Se puede facilitar el acceso utilizando EntityManager.GetComponent&lt;T&gt;(int entity) que es un atajo para este mismo método. void AttachSystem(GameSystem system)​ Permite agregar un sistem a la escena. Una vez se ha agregado un sistema este automáticamente funcionará. "},{"title":"Animaciones","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/animation","content":"","keywords":""},{"title":"AnimationStore (struct)​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#animationstore-struct","content":"Este componente almacena una animación en HD y una animación en baja resolución. "},{"title":"Animation​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#animation","content":"Almacena una animación. "},{"title":"constructor​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#constructor","content":"Parámetros: texture texture2DframeCount int "},{"title":"GameSystem","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/System","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"GameSystem","url":"/VIPER-DOCS/docs/ECS/System#atributos","content":"bool IsRunning​ Este atributo permitirá saber si el sistema debe actualizarse, esto permite pausar sistemas dentro de una escena. "},{"title":"Métodos​","type":1,"pageTitle":"GameSystem","url":"/VIPER-DOCS/docs/ECS/System#métodos","content":"Dado que Scene es una clase abstracta se debe utilizar herencia. Los métodos marcados como virtual deben ser implementados. abstract void Update (GameScene scene)​ Al momento de generar un sistema se deberá sobrescribir este método, aquí es donde se deberá aplicar toda la lógica que transforme el estado de los componentes, por regla general un componente no se puede actualizar por si solo o no puede contener lógica que transforme su comportamiento, lo ideal sería que toda esta lógica se mantenga en el Update. Aún así si la complejidad dentro del sistema crece se puede crear una clase de tipo utilidad que ejecute lógica y referenciarla en este método. "},{"title":"Camera","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/camera","content":"","keywords":""},{"title":"Implementaciones​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#implementaciones","content":""},{"title":"Camera2D​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#camera2d","content":"Esta es la cámara por defecto. Se le puede setear una posición XY a través de su variable position. "},{"title":"CameraTopDown​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#cameratopdown","content":"Esta implementación de la cámara sigue a una entidad tanto en el eje x como en el eje y. Funciona como una cámara de vista cenital ideal para rpgs. Tiene una variable privada CAMARA_SMOOTHING=10 que determina que tan suave debe moverse la cámara para dar la sensación de seguimiento al personaje en lugar de que la cámara este pegada al player. "},{"title":"Fullscreen","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/fullscreen","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#atributos","content":"public bool _isFullscreen (false) "},{"title":"_isFullscreen (bool)​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#_isfullscreen-bool","content":"Esta propiedad permite saber si la aplicación se está visualizando actualmente en fullScreen. En GameManager se utiliza para saber si en caso de que la aplicación este en pantalla completa se utilice la resolución máxima (1920x1080). Importante Se debe implementar una forma de obtener la resolución del host y setear esa como la resolución de pantalla completa "},{"title":"Métodos públicos​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#métodos-públicos","content":"void ToggleFullscreen()void ToggleBorderless() "},{"title":"ToggleFullscreen​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#togglefullscreen","content":"Este método alterna entre pantalla completa y modo ventana cada vez que se ejecuta. "},{"title":"ToggleBorderless​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#toggleborderless","content":"Este método alterna entre pantalla completa en modo borderless y modo ventana. "},{"title":"constructor​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#constructor","content":"FullScreen(GraphicsDeviceManager, GameWindow, Vector2) "},{"title":"Physics","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/physics","content":"","keywords":""},{"title":"MovePhysics​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#movephysics","content":"Componente con fisicas para un plataformero 2D. Utiliza un mapa del tipo TileMap. "},{"title":"Atributos​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#atributos","content":"gravity float (gravedad sobre el eje Y en caso de estar en el aire).topSpeed float (máxima velocidad aplicable, se aplica para el eje Y).velocity float (delta de velocidad acumulada en el eje Y).jump float (fuerza de salto en eje Y).xVelocity float (delta de velocidad acumulada en el eje X).topSpeedX float (máxima velocidad posible en eje X).acc float (cuanto acumula de velocidad por frame).airAcc float (cuanto acumula de velocidad por frame en el aire).deacc float (deaceleración en caso de que x sea mayor o menor a 0).friction float (desaceleración en el eje x por fricción con suelo).airFriction float (desaceleración en el eje x por fricción con el aire). "},{"title":"Métodos​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#métodos","content":"Move(Vector2 direction)​ Este método se encarga de actualizar las físicas de acuerdo a los valores de velocity y xVelocity aplicando la influencia de dirección pasada por parámetros y aplicando también la lógica de físicas ya sean colisiones con el mapa o factores como desaceleración o fricción con el suelo/aire, etc. En caso de no ejecutarse las físicas no se actualizarán, esto podría ser de utilidad en algún caso donde se deba detener en el aire el personaje, o quizá en caso de implementar un nuevo modo de movimiento se puede suspender la ejecución del move para utilizar otro tipo de movimiento en su lugar, como movimiento volador, etc. "},{"title":"Input","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/input","content":"","keywords":""},{"title":"GetKeyDown(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeydownkeys-key","content":"Retorna true si la tecla indicada fue presionada en el frame actual. "},{"title":"GetKeyUp(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeyupkeys-key","content":"Retorna true si la tecla indicada fue levantada en el frame actual. "},{"title":"GetKey(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeykeys-key","content":"Al igual que el método clásico verifica si la tecla actual está siendo presionada. "},{"title":"LeftClick​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#leftclick","content":"Retorna true si el click izquierdo fue presionado durante ese frame. "},{"title":"RightClick​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#rightclick","content":"Retorna true si el click derecho fue presionado durante ese frame. "},{"title":"MousePosition​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#mouseposition","content":"Retorna un objeto de tipo Vector2 con las coordenadas x e y del mouse. "},{"title":"GameInput class​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#gameinput-class","content":"esta clase funciona como una máscara para las acciones del juego, contiene los siguientes botones: LeftRightUpDownABStartSelect Esto permite que en lugar de asociar una acción a una tecla específica se puede mapear a uno de estos botones y al iniciar el juego se realizará la acción haciendo referencia a los botones del GameInput. Los valores de las teclas asociadas a estos gameInputs son indicados en un archivo dentro de la carpeta Content en la ruta Content/Text/input.properties Si se modifican estos valores esas asignaciones funcionarán como las teclas indicadas anteriormente. "},{"title":"GamepadVirtual class​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#gamepadvirtual-class","content":"Se creo esta clase para almacenar un gamepad virtual, este gamepadvirtual tiene una serie de botones definidos en un enum llamado GamepadButtons. La ventaja de esta clase es que al generar este controlador virtual se pueden generar definiciones de los botones que utiliza, de este modo se puede agregar una definición de teclado donde se mapean teclas por ejemplo ASDW como GamepadButton.LEFT/DOWN/RIGHT/UP, esto trae como ventaja el remapeo de un gamepad sin necesidad de tocar el código fuente donde se utiliza. Inicialmente se pueden mapear los botones en Content/Text/gamepad.properties. Además cuenta con un buffer de entrada que permite revisar los inputs realizados en los últimos frames, esto es útil para probar secuencias de algún comando como hacer un hadouken por ejemplo. Esta funcionalidad está disponible a través del método TestSequence(Queue&lt;GamepadButton&gt; list, bool cancelOnNeutral=false). Por defecto la clase Input genera un mando virtual para el player 0. Este se puede usar directamente, pero también se pueden agregar más players si es necesario. Siempre se debe acceder a la información de los gamepadvirtuales a través del singleton Input ya que este se encarga de refrescar la información correspondiente a estos botones. Se espera en el futuro actualizar este componente para usar un json en el almacenamiento de configuraciones y completar el soporte de un mando real como xbox, ps5, etc. "},{"title":"Graphics","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/graphics","content":"","keywords":""},{"title":"DrawFigures​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawfigures","content":""},{"title":"DrawRect​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawrect","content":"Permite dibujar el rectángulo indicado en parámetros (se dibuja como un rectángulo vacío sin relleno). "},{"title":"DrawRectFilled​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawrectfilled","content":"Permite dibujar el rectángulo indicado en parámetros. "},{"title":"DrawFormTile​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawformtile","content":"Dibuja un tile en la pantalla considerando que los tiles sean definidos por ejemplo como 16x16 y uno de estos está ubicado en el tile map (1, 0) se dibujará en las coordenadas (16, 0) con un width, height de 16x16. "},{"title":"DrawFlatTile​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawflattile","content":"Siguiendo la lógica anterior se dibujará solo una línea sobre el tile indicado. Funciona como una especie de línea recta que marca el piso por donde se está pasando. "},{"title":"DrawLine​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawline","content":"Permite dibujar una línea entre un punto A(x,y) y un punto B(x,y). "},{"title":"DrawTriangle​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawtriangle","content":"Permite dibujar un triángulo con un ángulo recto, parecido a DrawLine, pero dibujar el triángulo correspondiente a esa línea. "},{"title":"DrawUtils​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawutils","content":""},{"title":"Draw​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#draw","content":"Permite dibujar una textura en la posición indicada. "},{"title":"DrawHD​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawhd","content":"Permite dibujar una textura en modo HD, este método se deberá utilizar en el método DrawHD de alguna entidad o escena que lo requiera. "},{"title":"DrawHUD​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawhud","content":"Este método permite dibujar en pantalla y que los elementos dibujados ignoren el sistema de cámara, por lo que siempre se mostrarán a pesar del desplazamiento generado por el componente de Camera2D. Idealmente especial para dibujar HUD, elementos que necesiten estar estáticos en pantalla como estado del personaje. "},{"title":"DrawToRectangle​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawtorectangle","content":"Parecido al método original para dibujar en pantalla. La adición es que en este método se puede transformar el rectángulo dibujado a uno nuevo y este será el resultante. Esto permite escalar una imagen en el eje x o y. "},{"title":"DrawGrid​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawgrid","content":"Permite dibujar una grilla en pantalla. Este método se puede utilzar, o se utiliza en el modo debug, es muy útil para dimensionar las distancias entre cada tile. "},{"title":"Game Manager (Singleton)","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/game_manager","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#atributos","content":""},{"title":"Modificables​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#modificables","content":"const INTERNAL_RES INTERNAL_RESOLUTION​ Indica la resolución virtual. La idea de este motor es poder realizar cálculos en una resolución virtual más baja y luego mostrar gráficos en alta resolución. Por ejemplo trabajar con tiles de 16x16 en una resolución interna de 640x360 y escalar a 48x48 con resolución 1920x1080 (x3). const RES RESOLUTION​ Indica la resolución de la pantalla. La resolución real que será visualizada por el usuario. const bool HD_MODE​ Indica si la visualización está en modo HD o en modo no escalada. Esto permite agilizar el desarrollo visualizando directamente la resolución virtual. Luego al alternar a modo HD se podrá ver la resolución final. bool Debug​ Indicar si la ejecución está en modo debug. Esta variable será utilizada por otras clases a modo de realizar pruebas, para habilitar/deshabilitar elementos debug. bool Pause​ Permite pausar el juego. Si esta variable está activa los métodos update de escenas entidad componentes no se ejecutarán. Scene​ La escena activa actual. Se puede cambiar por una nueva escena. Camera​ La cámara utilizada actualmente. Se puede reemplazar por otra cámara en caso de necesitar crear una cámara nueva. Window​ Permite el acceso a variables de configuración del objeto Window GraphicsDevice​ Permite acceder a graphicsDevice para configuración. GraphicsDeviceManager​ Permite acceder o utilizar el graphicDeviceManager para configuración. Content​ Permite acceder al contenido almacenado, será utilizado por elementos que necesiten cargar datos. FullScreen FullScreenManager​ Instancia de FullScreen, esta será utilizable por Manager para cambios en la visualización. Input​ Instancia de input única para el manejo de inputs de usuario. IGameParameters GameParameters​ Permite Indicar variables iniciales para el juego. Definiciones como el nombre del juego, datos de usuario, etc. DialogBox​ Instancia de dialogbox utilizable para mostrar texto en pantalla (Ideal para rpg). "},{"title":"Read only​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#read-only","content":"GameManager Instance​ La instancia del gamemanager. Esta sería el punto de entrada al game manager para acceder a cada uno de sus atributos y métodos. SCALE​ Entrega la proporción de escala entre la resolución interna (virtual) y la resolución de la pantalla. ResolutionScale​ Entrega la proporción inversa de escala entre la resolución interna (virtual) y la resolución de la pantalla. DefaultFont​ Entrega una fuente de texto por defecto, esta se puede utilizar para mostrar texto en pantalla. "},{"title":"Métodos​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#métodos","content":""},{"title":"Update(GameTime)​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#updategametime","content":"Se maneja la lógica que debe actualizar cuadro a cuadro. Este método es ideal para agregar funciones globales que afectan a toda la aplicación, por ejemplo el control de pantalla completa o alternar entre modo debug y normal o modo hd/low res. "},{"title":"Screen","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/screen","content":"Screen Screen es un componente que funciona como un RenderTarget. La idea es simplificar este proceso de creación de render Target funcionando simplemente como un lienzo que uno activa a través de screen.Set() dibuja y luego desactiva el lienzo con screen.UnSet(). Finalmente al momento de pintar elementos se puede utilizar screen como si fuera una textura, esto permite escalar, rotar, transformar el lienzo original, además de otros tratamientos que se aplican al dibujo a través de SpriteBatch. Este componente se utiliza cuando se renderiza la pantalla virtual a pantalla en lugar de su versión HD. Lo que se hace en este caso es pintar en un lienzo con el tamaño original y luego se escala al tamaño de la pantalla. Una limitación de este componente es que solo se puede utilizar en la clase Main (la que extiende de Game) ya que ahi es donde se realiza el draw principal. Si es necesario generar renderTargets para otras tareas quiza la mejor idea sea generar una cola de procesos de dibujo y llamar a esa cola durante el draw.","keywords":""},{"title":"UI","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/ui","content":"","keywords":""},{"title":"Button Entity​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#button-entity","content":"Permite instanciar un botón. "},{"title":"Atributos​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#atributos","content":"padding​ permite indicar cuanto se debe enchanzar el botón. "},{"title":"Label​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#label","content":"La etiqueta contenida en el botón. ColorNormal​ Color del botón en modo normal. ColorHover​ Color del botón cuando se presiona. "},{"title":"Métodos​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#métodos","content":"SetActionListener​ Permite asignar un callback una vez el botón haya sido presionado. "},{"title":"FrameDataComponent","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"FrameDataComponent","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent#atributos","content":"currentAnimation FrameData​ Entrega la animación actual en formato FrameData. Esto contiene la información completa de la animación, tanto frames, como hitboxes, etc. currentFrame int​ Indica el cuadro actual de animación, Es esencial para saber que tipo de hitbox está activa en ese cuadro y la animación que se reproduce en el mismo. onEndAnimation action​ Este atributo funciona como una acción, es decir que se puede agregar un método callback a este atributo y cuando se cumpla el ciclo de la animación esta acción ejecutará todos los métodos suscritos a ella. "},{"title":"Métodos​","type":1,"pageTitle":"FrameDataComponent","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent#métodos","content":"Update (GameTime time) void​ Método update que se actualiza cuadro a cuadro, si hay una animación activa irá realizando el flujo de la animación cuadro por cuadro. getLayer(int index) Layer​ Retorna la capa que se haya indicado por index, esto debe ser de conocimiento previo para el usuario. Las capas contienen el tipo de hitbox. Por ejemplo si necesito calcular si un golpe le ha dado a la entidad, puedo obtener la capa de &quot;Hurtbox&quot; y comprobar si los hitbox del oponente solapan con algún hitbox de este hurtbox en el cuadro actual, para eso puedo obtener estas capa y luego utilizando currentFrame podré obtener los cuadros de hurtbox que existen en el cuadro actual. getHitboxes() List&lt;Hitbox&gt;​ Retorna las hitboxes del cuadro que está desplegandose en pantalla en ese momento. Este método es útil para obtener directamente todo lo que se ejecuta en el momento y realizar un cruce de hitboxes entre entidades. getCurrentSprite() Texture2D​ retorna el sprite actual según el valor de currentFrame. getCurrentPointer() int​ retorna el frame actual. Este tipo de animaciones cuadro a cuadro funciona con keyFrames, esto quiere decir que hay cuadros de animación que duran más que otros, esto significa que la animación en sí, si es de 4 frames por ejemplo, no significa que a nivel de código en 4 ciclos se complete la animación, cada frame tiene un campo duración y ese es el determinante de cuanto durará cada frame a nivel de código. En base a esta definición, este método retornará el frame de la animación que está siendo mostrada (o sea el puntero de la animación de frameData) en base a cuantos cuadros han pasado en la aplicación desde que inició la animación actual. getAnimationDuration() int​ Retorna la duración real en frames de la animación, esto significa sumar la duración de cada frame individual de frameData (no confundir con la cantidad de frames de FrameData). Draw(SpriteBatch _sb) void​ Método que dibuja el cuadro de animación actual, se debe ejecutar en el método Draw de la entidad que lo consuma. Esto facilita al programador para evitar tener que realizar los trabajos de dibujo manualmente, por lo que se recomienda su uso. DrawDebug(SpriteBatch _sb, Texture2D t) void​ Método bastante útil si se necesita dibujar los hitbox en pantalla, en caso de necesitar realizar depuración o tener una visualización de los hitbox se puede utilizar este método. "},{"title":"TextDisplay","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/textdisplay","content":"","keywords":""},{"title":"Texts Singleton​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#texts-singleton","content":"Esta clase es la encargada de leer todos los textos de la aplicación, a través de Text.GetText(&quot;codigo.de.texto&quot;) permitirá obtener la etiqueta asociada al código codigo.de.texto en el archivo Content/Text/npc_dialogs.properties. Como se puede inferir en este último punto, esta funcionalidad no está del todo acabada, por lo que en un futuro se podría modificar el archivo que consume para estos textos y no limitarlo solo a npc, sino a todo texto de la aplicación que sería lo ideal. "},{"title":"DialogBox Entity​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#dialogbox-entity","content":"Dialogbox es una entidad que permite el despliegue de cuadros de textos en la aplicación, en resumen es una utilidad rápida y básica para desplegar textos como si de un juego rpg se tratase, la idea es simplificar los procesos. Calcula automáticamente cuanto texto mostrar por pantalla y contiene métodos mínimos para su gestionamiento. "},{"title":"Métodos​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#métodos","content":"Esta clase se pensó para que su forma de ser utilizada sea la más simple posible, por lo mismo su gestionamiento se realiza automáticamente al colgar cualquier tipo de pantalla y en cualquier punto de la aplicación se podrá desplegar un dialogo de texto utilzando sus métodos estáticos sin necesidad de generar una instancia del dialogBox. ShowText (string text) static void​ Permite desplegar un texto cualquiera, este texto se motrará en pantalla sobre todo lo demás. Considerar que este texto desplegado no se quitará automaticamente por lo que será necesario utilizar el método NextSentence() en algún botón para que avance el texto indicado. NextSentence static void​ Se encarga de gestionar el progreso de una cadena de texto, avanzará al siguiente cuadro de texto en caso de que haya uno disponible, en caso de que se haya acabado el texto a desplegar este método cerrará la ventana. "},{"title":"Introducción","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/intro","content":"Introducción Viper engine es un motor de videojuegos 2D hecho en Monogame. Implementa el sistema de Entidad-Componente-Escena y agrega algunas funcionalidades de herramientas de importación para el manejo de datos.","keywords":""},{"title":"MapEditor","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/mapeditor","content":"","keywords":""},{"title":"MapLevel​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#maplevel","content":"Almacena la información de un nivel, los tiles que contiene y las lineas que también almacena, estos los almacena en las siguientes listas: tileList: lista con tiles repartidos en el mapa.lineList: lista de lineas repartidas en el mapa.groundList: lista de líneas que funcionan como suelo en el mapa.wallList: lista de líneas que funcionan como murallas en el mapa.slopeList: lista de líneas que funcionan como inclinaciones en el suelo del mapa. "},{"title":"MapLine​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#mapline","content":"Esta clase contiene las definiciones de una línea de un punto A(x, y) a un punto B(x, y) en el contexto de un MapLevel. Se utiliza como se comentó en MapLevel para definir distintos tipos de restricciones de movimiento como suelo, murallas y slopes. "},{"title":"MapTile​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#maptile","content":"Esta clase contiene las definiciones para agregar un tile (unidad mínima en mapa, por lo general de 16x16), simplemente define su posición en un punto (x, y). Además contiene banderas útiles como solid que permite saber si este objeto puede utilizarse como una plataforma por la que subir por abajo. "}]