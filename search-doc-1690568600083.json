[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/first-blog-post","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":""},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/VIPER-DOCS/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"Component","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/component","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Component","url":"/VIPER-DOCS/docs/ECS/component#atributos","content":"ParentEntity​ La entidad a la que el componente pertenece. Este valor Será informado luego de ser agregado a la entidad, por lo que durante la ejecución del método Initialize del componente este valor estará informado. ParentPosition​ Este atributo es un atajo para ParentEntity.position, dado que se referencia en reiteradas ocasiones se creo este atributo para obtener el dato como un acceso directo. "},{"title":"Métodos​","type":1,"pageTitle":"Component","url":"/VIPER-DOCS/docs/ECS/component#métodos","content":"AddComponent(Component comp)​ Permite agregar un componente a la entidad padre. Si bien en este punto un componente no puede tener componentes hijos, este addComponent funciona como un shortcut a ParentEntity.AddComponent. Se utiliza para bajar la complejidad ciclomática. GetComponent &lt;T&gt; where T : Component​ Al igual que el caso anterior, este es un atajo para ParentEntity.GetComponent(). Simplemente para bajar la complejidad ciclomática y simplificar el desarrollo. Initialize () virtual​ Este método se ejecutará una vez se haya registrado el componente dentro de una entidad activa. Así como el constructor inicializa una instancia de un objeto, este método inicializa la instancia del objeto en un videojuego en tiempo real. Update(GameTime time) virtual​ Actualización cuadro a cuadro del componente, este método (como en casos anteriores) debe ejecutar previamente su base. Ideal para hacer cálculos en tiempo real. "},{"title":"Entity","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/entity","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Entity","url":"/VIPER-DOCS/docs/ECS/entity#atributos","content":"componentList List&lt;Component&gt;​ Almacena la lista de componentes que pertenecen a la entidad actual. Si se quiere registrar un componente se debe utilizar AddComponent(component). Utilizar esta lista sólo para leer datos, no para insertar componentes nuevos. Layer​ Determina la capa de prioridad donde se dibujará la entidad. Position​ La posición de la entidad dentro de la escena Origin​ El punto de origen en la entidad (limitados dentro del cuadrado(0.0, 0.0), (1.0,1.0)). FlipX​ Se muestra la textura en modo espejo en el eje X. FlipY​ Se muestra la textura en modo espejo en el eje Y. "},{"title":"Métodos​","type":1,"pageTitle":"Entity","url":"/VIPER-DOCS/docs/ECS/entity#métodos","content":"Dado que Scene es una clase abstracta se debe utilizar herencia. Los métodos marcados como virtual deben ser implementados. AddComponent(Component comp)​ Permite agregar un componente a la entidad. Es importante utilizar este método en lugar de agregarlo en la lista directamente, esto permitirá que la carga del componente sea la correcta y se pueda ejecutar el método Initialize sin problemas. GetComponent &lt;T&gt; where T : Component​ Permite obtener un componente que ya ha sido agregado a la entidad. En caso de que no exista devolverá nulo. Es especialmente útil si durante un método update necesito hacer un check de algún componente. DrawPositionPointer​ Se puede utilizar para dibujar una cruz sobre la posición de la entidad actual. Esto es útil para mantener un seguimiento visual de la entidad en caso de que no tenga una textura agregada como componente o su método draw no dibuje nada. La ejecución de este DrawPositionPointer debe realizarse dentro de alguno de los métodos Draw. Initialize virtual​ Método que inicializa la entidad. En este punto la entidad tiene acceso a la escena donde se ha agregado por lo que este método es útil si se necesita obtener información o interactuar con alguna propiedad de la escena. Update virtual​ Método para actualizar la entidad cuadro por cuadro. Es importante que al igual que en otros casos este método se ejecute manteniendo la ejecución del método base. Esto para que el método base sea capaz de actualizar los componentes que pertenecen a esta entidad. Draw abstract​ Método para dibujar las texturas necesarias por la entidad. Como los componentes no requieren necesariamente ser impresos, este método es útil para llamar algún método Draw creado en un componente para dibujar sobre la entidad. DrawHD abstract​ Misma lógica anterior esta vez para dibujar en modo HD. Si HD_MODE=true este método se ejecutara en lugar de método Draw. "},{"title":"Scene","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/ECS/scene","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Scene","url":"/VIPER-DOCS/docs/ECS/scene#atributos","content":"entityList List&lt;Entity&gt;​ Almacena la lista de entidades que pertenecen a la escena actual. Si se quiere registrar una entidad se debe utilizar AddEntity(entity). Utilizar esta lista sólo para leer datos, no para insertar entidades nuevas. "},{"title":"Métodos​","type":1,"pageTitle":"Scene","url":"/VIPER-DOCS/docs/ECS/scene#métodos","content":"Dado que Scene es una clase abstracta se debe utilizar herencia. Los métodos marcados como virtual deben ser implementados. AddEntity (Entity ent)​ A través de este método se deberán registrar nuevas entidades en la escena. En caso de no registrar la entidad, esta no será capaz de ejecutar sus métodos update y de dibujarla en pantalla. Update (GameTime gametime) virtual​ Este método se ejecuta cada ciclo de juego (60fps). Es importante que en la implementación se haga la ejecución de la base para que se puedan actualizar también las entidades. Draw (SpriteBatch sb, Texture2D t) virtual​ Este método dibuja en pantalla durante cada ciclo de juego. Al igual que en update, este método debe ejecutar su método base para que se pueda actualizar el dibujo en entidades. DrawHD (SpriteBatch sb, Texture2D t) virtual​ Este método dibuja sprites si el modo HD está en estado true. DrawDebug (SpriteBatch sb, Texture2D t) virtual​ Este método dibuja sprites si el modo debug está en estado true. "},{"title":"Animaciones","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/animation","content":"","keywords":""},{"title":"AnimationStore (struct)​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#animationstore-struct","content":"Este componente almacena una animación en HD y una animación en baja resolución. "},{"title":"Animation​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#animation","content":"Almacena una animación. "},{"title":"constructor​","type":1,"pageTitle":"Animaciones","url":"/VIPER-DOCS/docs/Engine/animation#constructor","content":"Parámetros: texture texture2DframeCount int "},{"title":"Camera","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/camera","content":"","keywords":""},{"title":"Implementaciones​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#implementaciones","content":""},{"title":"Camera2D​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#camera2d","content":"Esta es la cámara por defecto. Se le puede setear una posición XY a través de su variable position. "},{"title":"CameraTopDown​","type":1,"pageTitle":"Camera","url":"/VIPER-DOCS/docs/Engine/camera#cameratopdown","content":"Esta implementación de la cámara sigue a una entidad tanto en el eje x como en el eje y. Funciona como una cámara de vista cenital ideal para rpgs. Tiene una variable privada CAMARA_SMOOTHING=10 que determina que tan suave debe moverse la cámara para dar la sensación de seguimiento al personaje en lugar de que la cámara este pegada al player. "},{"title":"Game Manager (Singleton)","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/game_manager","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#atributos","content":""},{"title":"Modificables​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#modificables","content":"const INTERNAL_RES INTERNAL_RESOLUTION​ Indica la resolución virtual. La idea de este motor es poder realizar cálculos en una resolución virtual más baja y luego mostrar gráficos en alta resolución. Por ejemplo trabajar con tiles de 16x16 en una resolución interna de 640x360 y escalar a 48x48 con resolución 1920x1080 (x3). const RES RESOLUTION​ Indica la resolución de la pantalla. La resolución real que será visualizada por el usuario. const bool HD_MODE​ Indica si la visualización está en modo HD o en modo no escalada. Esto permite agilizar el desarrollo visualizando directamente la resolución virtual. Luego al alternar a modo HD se podrá ver la resolución final. bool Debug​ Indicar si la ejecución está en modo debug. Esta variable será utilizada por otras clases a modo de realizar pruebas, para habilitar/deshabilitar elementos debug. bool Pause​ Permite pausar el juego. Si esta variable está activa los métodos update de escenas entidad componentes no se ejecutarán. Scene​ La escena activa actual. Se puede cambiar por una nueva escena. Camera​ La cámara utilizada actualmente. Se puede reemplazar por otra cámara en caso de necesitar crear una cámara nueva. Window​ Permite el acceso a variables de configuración del objeto Window GraphicsDevice​ Permite acceder a graphicsDevice para configuración. GraphicsDeviceManager​ Permite acceder o utilizar el graphicDeviceManager para configuración. Content​ Permite acceder al contenido almacenado, será utilizado por elementos que necesiten cargar datos. FullScreen FullScreenManager​ Instancia de FullScreen, esta será utilizable por Manager para cambios en la visualización. Input​ Instancia de input única para el manejo de inputs de usuario. IGameParameters GameParameters​ Permite Indicar variables iniciales para el juego. Definiciones como el nombre del juego, datos de usuario, etc. DialogBox​ Instancia de dialogbox utilizable para mostrar texto en pantalla (Ideal para rpg). "},{"title":"Read only​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#read-only","content":"GameManager Instance​ La instancia del gamemanager. Esta sería el punto de entrada al game manager para acceder a cada uno de sus atributos y métodos. SCALE​ Entrega la proporción de escala entre la resolución interna (virtual) y la resolución de la pantalla. ResolutionScale​ Entrega la proporción inversa de escala entre la resolución interna (virtual) y la resolución de la pantalla. DefaultFont​ Entrega una fuente de texto por defecto, esta se puede utilizar para mostrar texto en pantalla. "},{"title":"Métodos​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#métodos","content":""},{"title":"Update(GameTime)​","type":1,"pageTitle":"Game Manager (Singleton)","url":"/VIPER-DOCS/docs/Engine/game_manager#updategametime","content":"Se maneja la lógica que debe actualizar cuadro a cuadro. Este método es ideal para agregar funciones globales que afectan a toda la aplicación, por ejemplo el control de pantalla completa o alternar entre modo debug y normal o modo hd/low res. "},{"title":"Fullscreen","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/fullscreen","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#atributos","content":"public bool _isFullscreen (false) "},{"title":"_isFullscreen (bool)​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#_isfullscreen-bool","content":"Esta propiedad permite saber si la aplicación se está visualizando actualmente en fullScreen. En GameManager se utiliza para saber si en caso de que la aplicación este en pantalla completa se utilice la resolución máxima (1920x1080). Importante Se debe implementar una forma de obtener la resolución del host y setear esa como la resolución de pantalla completa "},{"title":"Métodos públicos​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#métodos-públicos","content":"void ToggleFullscreen()void ToggleBorderless() "},{"title":"ToggleFullscreen​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#togglefullscreen","content":"Este método alterna entre pantalla completa y modo ventana cada vez que se ejecuta. "},{"title":"ToggleBorderless​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#toggleborderless","content":"Este método alterna entre pantalla completa en modo borderless y modo ventana. "},{"title":"constructor​","type":1,"pageTitle":"Fullscreen","url":"/VIPER-DOCS/docs/Engine/fullscreen#constructor","content":"FullScreen(GraphicsDeviceManager, GameWindow, Vector2) "},{"title":"Graphics","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/graphics","content":"","keywords":""},{"title":"DrawFigures​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawfigures","content":""},{"title":"DrawRect​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawrect","content":"Permite dibujar el rectángulo indicado en parámetros (se dibuja como un rectángulo vacío sin relleno). "},{"title":"DrawRectFilled​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawrectfilled","content":"Permite dibujar el rectángulo indicado en parámetros. "},{"title":"DrawFormTile​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawformtile","content":"Dibuja un tile en la pantalla considerando que los tiles sean definidos por ejemplo como 16x16 y uno de estos está ubicado en el tile map (1, 0) se dibujará en las coordenadas (16, 0) con un width, height de 16x16. "},{"title":"DrawFlatTile​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawflattile","content":"Siguiendo la lógica anterior se dibujará solo una línea sobre el tile indicado. Funciona como una especie de línea recta que marca el piso por donde se está pasando. "},{"title":"DrawLine​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawline","content":"Permite dibujar una línea entre un punto A(x,y) y un punto B(x,y). "},{"title":"DrawTriangle​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawtriangle","content":"Permite dibujar un triángulo con un ángulo recto, parecido a DrawLine, pero dibujar el triángulo correspondiente a esa línea. "},{"title":"DrawUtils​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawutils","content":""},{"title":"Draw​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#draw","content":"Permite dibujar una textura en la posición indicada. "},{"title":"DrawHD​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawhd","content":"Permite dibujar una textura en modo HD, este método se deberá utilizar en el método DrawHD de alguna entidad o escena que lo requiera. "},{"title":"DrawHUD​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawhud","content":"Este método permite dibujar en pantalla y que los elementos dibujados ignoren el sistema de cámara, por lo que siempre se mostrarán a pesar del desplazamiento generado por el componente de Camera2D. Idealmente especial para dibujar HUD, elementos que necesiten estar estáticos en pantalla como estado del personaje. "},{"title":"DrawToRectangle​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawtorectangle","content":"Parecido al método original para dibujar en pantalla. La adición es que en este método se puede transformar el rectángulo dibujado a uno nuevo y este será el resultante. Esto permite escalar una imagen en el eje x o y. "},{"title":"DrawGrid​","type":1,"pageTitle":"Graphics","url":"/VIPER-DOCS/docs/Engine/graphics#drawgrid","content":"Permite dibujar una grilla en pantalla. Este método se puede utilzar, o se utiliza en el modo debug, es muy útil para dimensionar las distancias entre cada tile. "},{"title":"Input","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/input","content":"","keywords":""},{"title":"GetKeyDown(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeydownkeys-key","content":"Retorna true si la tecla indicada fue presionada en el frame actual. "},{"title":"GetKeyUp(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeyupkeys-key","content":"Retorna true si la tecla indicada fue levantada en el frame actual. "},{"title":"GetKey(Keys key)​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#getkeykeys-key","content":"Al igual que el método clásico verifica si la tecla actual está siendo presionada. "},{"title":"LeftClick​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#leftclick","content":"Retorna true si el click izquierdo fue presionado durante ese frame. "},{"title":"RightClick​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#rightclick","content":"Retorna true si el click derecho fue presionado durante ese frame. "},{"title":"MousePosition​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#mouseposition","content":"Retorna un objeto de tipo Vector2 con las coordenadas x e y del mouse. "},{"title":"GameInput class​","type":1,"pageTitle":"Input","url":"/VIPER-DOCS/docs/Engine/input#gameinput-class","content":"esta clase funciona como una máscara para las acciones del juego, contiene los siguientes botones: LeftRightUpDownABStartSelect Esto permite que en lugar de asociar una acción a una tecla específica se puede mapear a uno de estos botones y al iniciar el juego se realizará la acción haciendo referencia a los botones del GameInput. Los valores de las teclas asociadas a estos gameInputs son indicados en un archivo dentro de la carpeta Content en la ruta Content/Text/input.properties Si se modifican estos valores esas asignaciones funcionarán como las teclas indicadas anteriormente. "},{"title":"Physics","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/physics","content":"","keywords":""},{"title":"MovePhysics​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#movephysics","content":"Componente con fisicas para un plataformero 2D. Utiliza un mapa del tipo TileMap. "},{"title":"Atributos​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#atributos","content":"gravity float (gravedad sobre el eje Y en caso de estar en el aire).topSpeed float (máxima velocidad aplicable, se aplica para el eje Y).velocity float (delta de velocidad acumulada en el eje Y).jump float (fuerza de salto en eje Y).xVelocity float (delta de velocidad acumulada en el eje X).topSpeedX float (máxima velocidad posible en eje X).acc float (cuanto acumula de velocidad por frame).airAcc float (cuanto acumula de velocidad por frame en el aire).deacc float (deaceleración en caso de que x sea mayor o menor a 0).friction float (desaceleración en el eje x por fricción con suelo).airFriction float (desaceleración en el eje x por fricción con el aire). "},{"title":"Métodos​","type":1,"pageTitle":"Physics","url":"/VIPER-DOCS/docs/Engine/physics#métodos","content":"Move(Vector2 direction)​ Este método se encarga de actualizar las físicas de acuerdo a los valores de velocity y xVelocity aplicando la influencia de dirección pasada por parámetros y aplicando también la lógica de físicas ya sean colisiones con el mapa o factores como desaceleración o fricción con el suelo/aire, etc. En caso de no ejecutarse las físicas no se actualizarán, esto podría ser de utilidad en algún caso donde se deba detener en el aire el personaje, o quizá en caso de implementar un nuevo modo de movimiento se puede suspender la ejecución del move para utilizar otro tipo de movimiento en su lugar, como movimiento volador, etc. "},{"title":"UI","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/ui","content":"","keywords":""},{"title":"Button Entity​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#button-entity","content":"Permite instanciar un botón. "},{"title":"Atributos​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#atributos","content":"padding​ permite indicar cuanto se debe enchanzar el botón. "},{"title":"Label​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#label","content":"La etiqueta contenida en el botón. ColorNormal​ Color del botón en modo normal. ColorHover​ Color del botón cuando se presiona. "},{"title":"Métodos​","type":1,"pageTitle":"UI","url":"/VIPER-DOCS/docs/Engine/ui#métodos","content":"SetActionListener​ Permite asignar un callback una vez el botón haya sido presionado. "},{"title":"FrameDataComponent","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent","content":"","keywords":""},{"title":"Atributos​","type":1,"pageTitle":"FrameDataComponent","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent#atributos","content":"currentAnimation FrameData​ Entrega la animación actual en formato FrameData. Esto contiene la información completa de la animación, tanto frames, como hitboxes, etc. currentFrame int​ Indica el cuadro actual de animación, Es esencial para saber que tipo de hitbox está activa en ese cuadro y la animación que se reproduce en el mismo. onEndAnimation action​ Este atributo funciona como una acción, es decir que se puede agregar un método callback a este atributo y cuando se cumpla el ciclo de la animación esta acción ejecutará todos los métodos suscritos a ella. "},{"title":"Métodos​","type":1,"pageTitle":"FrameDataComponent","url":"/VIPER-DOCS/docs/Extras/FrameDataComponent#métodos","content":"Update (GameTime time) void​ Método update que se actualiza cuadro a cuadro, si hay una animación activa irá realizando el flujo de la animación cuadro por cuadro. getLayer(int index) Layer​ Retorna la capa que se haya indicado por index, esto debe ser de conocimiento previo para el usuario. Las capas contienen el tipo de hitbox. Por ejemplo si necesito calcular si un golpe le ha dado a la entidad, puedo obtener la capa de &quot;Hurtbox&quot; y comprobar si los hitbox del oponente solapan con algún hitbox de este hurtbox en el cuadro actual, para eso puedo obtener estas capa y luego utilizando currentFrame podré obtener los cuadros de hurtbox que existen en el cuadro actual. getHitboxes() List&lt;Hitbox&gt;​ Retorna las hitboxes del cuadro que está desplegandose en pantalla en ese momento. Este método es útil para obtener directamente todo lo que se ejecuta en el momento y realizar un cruce de hitboxes entre entidades. getCurrentSprite() Texture2D​ retorna el sprite actual según el valor de currentFrame. getCurrentPointer() int​ retorna el frame actual. Este tipo de animaciones cuadro a cuadro funciona con keyFrames, esto quiere decir que hay cuadros de animación que duran más que otros, esto significa que la animación en sí, si es de 4 frames por ejemplo, no significa que a nivel de código en 4 ciclos se complete la animación, cada frame tiene un campo duración y ese es el determinante de cuanto durará cada frame a nivel de código. En base a esta definición, este método retornará el frame de la animación que está siendo mostrada (o sea el puntero de la animación de frameData) en base a cuantos cuadros han pasado en la aplicación desde que inició la animación actual. getAnimationDuration() int​ Retorna la duración real en frames de la animación, esto significa sumar la duración de cada frame individual de frameData (no confundir con la cantidad de frames de FrameData). Draw(SpriteBatch _sb) void​ Método que dibuja el cuadro de animación actual, se debe ejecutar en el método Draw de la entidad que lo consuma. Esto facilita al programador para evitar tener que realizar los trabajos de dibujo manualmente, por lo que se recomienda su uso. DrawDebug(SpriteBatch _sb, Texture2D t) void​ Método bastante útil si se necesita dibujar los hitbox en pantalla, en caso de necesitar realizar depuración o tener una visualización de los hitbox se puede utilizar este método. "},{"title":"MapEditor","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/mapeditor","content":"","keywords":""},{"title":"MapLevel​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#maplevel","content":"Almacena la información de un nivel, los tiles que contiene y las lineas que también almacena, estos los almacena en las siguientes listas: tileList: lista con tiles repartidos en el mapa.lineList: lista de lineas repartidas en el mapa.groundList: lista de líneas que funcionan como suelo en el mapa.wallList: lista de líneas que funcionan como murallas en el mapa.slopeList: lista de líneas que funcionan como inclinaciones en el suelo del mapa. "},{"title":"MapLine​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#mapline","content":"Esta clase contiene las definiciones de una línea de un punto A(x, y) a un punto B(x, y) en el contexto de un MapLevel. Se utiliza como se comentó en MapLevel para definir distintos tipos de restricciones de movimiento como suelo, murallas y slopes. "},{"title":"MapTile​","type":1,"pageTitle":"MapEditor","url":"/VIPER-DOCS/docs/Extras/mapeditor#maptile","content":"Esta clase contiene las definiciones para agregar un tile (unidad mínima en mapa, por lo general de 16x16), simplemente define su posición en un punto (x, y). Además contiene banderas útiles como solid que permite saber si este objeto puede utilizarse como una plataforma por la que subir por abajo. "},{"title":"Screen","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Engine/screen","content":"Screen Screen es un componente que funciona como un RenderTarget. La idea es simplificar este proceso de creación de render Target funcionando simplemente como un lienzo que uno activa a través de screen.Set() dibuja y luego desactiva el lienzo con screen.UnSet(). Finalmente al momento de pintar elementos se puede utilizar screen como si fuera una textura, esto permite escalar, rotar, transformar el lienzo original, además de otros tratamientos que se aplican al dibujo a través de SpriteBatch. Este componente se utiliza cuando se renderiza la pantalla virtual a pantalla en lugar de su versión HD. Lo que se hace en este caso es pintar en un lienzo con el tamaño original y luego se escala al tamaño de la pantalla.","keywords":""},{"title":"TextDisplay","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/Extras/textdisplay","content":"","keywords":""},{"title":"Texts Singleton​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#texts-singleton","content":"Esta clase es la encargada de leer todos los textos de la aplicación, a través de Text.GetText(&quot;codigo.de.texto&quot;) permitirá obtener la etiqueta asociada al código codigo.de.texto en el archivo Content/Text/npc_dialogs.properties. Como se puede inferir en este último punto, esta funcionalidad no está del todo acabada, por lo que en un futuro se podría modificar el archivo que consume para estos textos y no limitarlo solo a npc, sino a todo texto de la aplicación que sería lo ideal. "},{"title":"DialogBox Entity​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#dialogbox-entity","content":"Dialogbox es una entidad que permite el despliegue de cuadros de textos en la aplicación, en resumen es una utilidad rápida y básica para desplegar textos como si de un juego rpg se tratase, la idea es simplificar los procesos. Calcula automáticamente cuanto texto mostrar por pantalla y contiene métodos mínimos para su gestionamiento. "},{"title":"Métodos​","type":1,"pageTitle":"TextDisplay","url":"/VIPER-DOCS/docs/Extras/textdisplay#métodos","content":"Esta clase se pensó para que su forma de ser utilizada sea la más simple posible, por lo mismo su gestionamiento se realiza automáticamente al colgar cualquier tipo de pantalla y en cualquier punto de la aplicación se podrá desplegar un dialogo de texto utilzando sus métodos estáticos sin necesidad de generar una instancia del dialogBox. ShowText (string text) static void​ Permite desplegar un texto cualquiera, este texto se motrará en pantalla sobre todo lo demás. Considerar que este texto desplegado no se quitará automaticamente por lo que será necesario utilizar el método NextSentence() en algún botón para que avance el texto indicado. NextSentence static void​ Se encarga de gestionar el progreso de una cadena de texto, avanzará al siguiente cuadro de texto en caso de que haya uno disponible, en caso de que se haya acabado el texto a desplegar este método cerrará la ventana. "},{"title":"Introducción","type":0,"sectionRef":"#","url":"/VIPER-DOCS/docs/intro","content":"Introducción Viper engine es un motor de videojuegos 2D hecho en Monogame. Implementa el sistema de Entidad-Componente-Escena y agrega algunas funcionalidades de herramientas de importación para el manejo de datos.","keywords":""}]