"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4875],{3905:(e,a,t)=>{t.d(a,{Zo:()=>s,kt:()=>b});var n=t(7294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function d(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=n.createContext({}),l=function(e){var a=n.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},s=function(e){var a=l(e.components);return n.createElement(c.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},p=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),u=l(t),p=i,b=u["".concat(c,".").concat(p)]||u[p]||m[p]||o;return t?n.createElement(b,r(r({ref:a},s),{},{components:t})):n.createElement(b,r({ref:a},s))}));function b(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=p;var d={};for(var c in a)hasOwnProperty.call(a,c)&&(d[c]=a[c]);d.originalType=e,d[u]="string"==typeof e?e:i,r[1]=d;for(var l=2;l<o;l++)r[l]=t[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8301:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var n=t(7462),i=(t(7294),t(3905));const o={sidebar_position:1},r="FrameDataComponent",d={unversionedId:"Extras/FrameDataComponent",id:"Extras/FrameDataComponent",title:"FrameDataComponent",description:"FrameDataComponent es un componente que gestiona una animaci\xf3n del tipo FrameData. Este tipo de datos se generan a partir de la aplicaci\xf3n FrameDataManager creada para manejar animaciones junto a sus hitboxes o cajas de colisiones de distintos tipos.",source:"@site/docs/Extras/FrameDataComponent.md",sourceDirName:"Extras",slug:"/Extras/FrameDataComponent",permalink:"/VIPER-DOCS/docs/Extras/FrameDataComponent",draft:!1,editUrl:"https://github.com/GinoMoena/VIPER-DOCS/docs/Extras/FrameDataComponent.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Extras",permalink:"/VIPER-DOCS/docs/category/extras"},next:{title:"MapEditor",permalink:"/VIPER-DOCS/docs/Extras/mapeditor"}},c={},l=[{value:"Atributos",id:"atributos",level:3},{value:"currentAnimation <code>FrameData</code>",id:"currentanimation-framedata",level:4},{value:"currentFrame <code>int</code>",id:"currentframe-int",level:4},{value:"onEndAnimation <code>action</code>",id:"onendanimation-action",level:4},{value:"M\xe9todos",id:"m\xe9todos",level:3},{value:"Update (GameTime time) <code>void</code>",id:"update-gametime-time-void",level:4},{value:"getLayer(int index) <code>Layer</code>",id:"getlayerint-index-layer",level:4},{value:"getHitboxes() <code>List&lt;Hitbox&gt;</code>",id:"gethitboxes-listhitbox",level:4},{value:"getCurrentSprite() <code>Texture2D</code>",id:"getcurrentsprite-texture2d",level:4},{value:"getCurrentPointer() <code>int</code>",id:"getcurrentpointer-int",level:4},{value:"getAnimationDuration() <code>int</code>",id:"getanimationduration-int",level:4},{value:"Draw(SpriteBatch _sb) <code>void</code>",id:"drawspritebatch-_sb-void",level:4},{value:"DrawDebug(SpriteBatch _sb, Texture2D t) <code>void</code>",id:"drawdebugspritebatch-_sb-texture2d-t-void",level:4}],s={toc:l},u="wrapper";function m(e){let{components:a,...t}=e;return(0,i.kt)(u,(0,n.Z)({},s,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"framedatacomponent"},"FrameDataComponent"),(0,i.kt)("p",null,"FrameDataComponent es un componente que gestiona una animaci\xf3n del tipo ",(0,i.kt)("inlineCode",{parentName:"p"},"FrameData"),". Este tipo de datos se generan a partir de la aplicaci\xf3n FrameDataManager creada para manejar animaciones junto a sus hitboxes o cajas de colisiones de distintos tipos."),(0,i.kt)("p",null,"Dado que es el componente que gestiona estas animaciones este ser\xe1 el responsable de entregar informaci\xf3n como la animaci\xf3n que est\xe1 en proceso, el cuadro de animaci\xf3n activo, los hitbox activos en ese proceso y adem\xe1s permite suscribir acciones (o callbacks) para que al terminar una animaci\xf3n se ejecute un cuadro de c\xf3digo. Esto \xfaltimo es especialmente \xfatil cuando tienes animaciones que se deben ejecutar una sola vez y luego se debe retornar al estado anterior como realizar un jab, un golpe a\xe9reo, o cualquier animaci\xf3n que saque a la entidad de su estado de animaci\xf3n neutral."),(0,i.kt)("h3",{id:"atributos"},"Atributos"),(0,i.kt)("h4",{id:"currentanimation-framedata"},"currentAnimation ",(0,i.kt)("inlineCode",{parentName:"h4"},"FrameData")),(0,i.kt)("p",null,"Entrega la animaci\xf3n actual en formato ",(0,i.kt)("inlineCode",{parentName:"p"},"FrameData"),". Esto contiene la informaci\xf3n completa de la animaci\xf3n, tanto frames, como hitboxes, etc."),(0,i.kt)("h4",{id:"currentframe-int"},"currentFrame ",(0,i.kt)("inlineCode",{parentName:"h4"},"int")),(0,i.kt)("p",null,"Indica el cuadro actual de animaci\xf3n, Es esencial para saber que tipo de hitbox est\xe1 activa en ese cuadro y la animaci\xf3n que se reproduce en el mismo."),(0,i.kt)("h4",{id:"onendanimation-action"},"onEndAnimation ",(0,i.kt)("inlineCode",{parentName:"h4"},"action")),(0,i.kt)("p",null,"Este atributo funciona como una acci\xf3n, es decir que se puede agregar un m\xe9todo callback a este atributo y cuando se cumpla el ciclo de la animaci\xf3n esta acci\xf3n ejecutar\xe1 todos los m\xe9todos suscritos a ella."),(0,i.kt)("h3",{id:"m\xe9todos"},"M\xe9todos"),(0,i.kt)("h4",{id:"update-gametime-time-void"},"Update (GameTime time) ",(0,i.kt)("inlineCode",{parentName:"h4"},"void")),(0,i.kt)("p",null,"M\xe9todo update que se actualiza cuadro a cuadro, si hay una animaci\xf3n activa ir\xe1 realizando el flujo de la animaci\xf3n cuadro por cuadro."),(0,i.kt)("h4",{id:"getlayerint-index-layer"},"getLayer(int index) ",(0,i.kt)("inlineCode",{parentName:"h4"},"Layer")),(0,i.kt)("p",null,'Retorna la capa que se haya indicado por index, esto debe ser de conocimiento previo para el usuario. Las capas contienen el tipo de hitbox. Por ejemplo si necesito calcular si un golpe le ha dado a la entidad, puedo obtener la capa de "Hurtbox" y comprobar si los hitbox del oponente solapan con alg\xfan hitbox de este hurtbox en el cuadro actual, para eso puedo obtener estas capa y luego utilizando ',(0,i.kt)("inlineCode",{parentName:"p"},"currentFrame")," podr\xe9 obtener los cuadros de hurtbox que existen en el cuadro actual."),(0,i.kt)("h4",{id:"gethitboxes-listhitbox"},"getHitboxes() ",(0,i.kt)("inlineCode",{parentName:"h4"},"List<Hitbox>")),(0,i.kt)("p",null,"Retorna  las hitboxes del cuadro que est\xe1 desplegandose en pantalla en ese momento. Este m\xe9todo es \xfatil para obtener directamente todo lo que se ejecuta en el momento y realizar un cruce de hitboxes entre entidades."),(0,i.kt)("h4",{id:"getcurrentsprite-texture2d"},"getCurrentSprite() ",(0,i.kt)("inlineCode",{parentName:"h4"},"Texture2D")),(0,i.kt)("p",null,"retorna el sprite actual seg\xfan el valor de ",(0,i.kt)("inlineCode",{parentName:"p"},"currentFrame"),"."),(0,i.kt)("h4",{id:"getcurrentpointer-int"},"getCurrentPointer() ",(0,i.kt)("inlineCode",{parentName:"h4"},"int")),(0,i.kt)("p",null,"retorna el frame actual. Este tipo de animaciones cuadro a cuadro funciona con keyFrames, esto quiere decir que hay cuadros de animaci\xf3n que duran m\xe1s que otros, esto significa que la animaci\xf3n en s\xed, si es de 4 frames por ejemplo, no significa que a nivel de c\xf3digo en 4 ciclos se complete la animaci\xf3n, cada frame tiene un campo duraci\xf3n y ese es el determinante de cuanto durar\xe1 cada frame a nivel de c\xf3digo. En base a esta definici\xf3n, este m\xe9todo retornar\xe1 el frame de la animaci\xf3n que est\xe1 siendo mostrada (o sea el puntero de la animaci\xf3n de frameData) en base a cuantos cuadros han pasado en la aplicaci\xf3n desde que inici\xf3 la animaci\xf3n actual."),(0,i.kt)("h4",{id:"getanimationduration-int"},"getAnimationDuration() ",(0,i.kt)("inlineCode",{parentName:"h4"},"int")),(0,i.kt)("p",null,"Retorna la duraci\xf3n real en frames de la animaci\xf3n, esto significa sumar la duraci\xf3n de cada frame individual de frameData (no confundir con la cantidad de frames de FrameData). "),(0,i.kt)("h4",{id:"drawspritebatch-_sb-void"},"Draw(SpriteBatch _sb) ",(0,i.kt)("inlineCode",{parentName:"h4"},"void")),(0,i.kt)("p",null,"M\xe9todo que dibuja el cuadro de animaci\xf3n actual, se debe ejecutar en el m\xe9todo Draw de la entidad que lo consuma. Esto facilita al programador para evitar tener que realizar los trabajos de dibujo manualmente, por lo que se recomienda su uso."),(0,i.kt)("h4",{id:"drawdebugspritebatch-_sb-texture2d-t-void"},"DrawDebug(SpriteBatch _sb, Texture2D t) ",(0,i.kt)("inlineCode",{parentName:"h4"},"void")),(0,i.kt)("p",null,"M\xe9todo bastante \xfatil si se necesita dibujar los hitbox en pantalla, en caso de necesitar realizar depuraci\xf3n o tener una visualizaci\xf3n de los hitbox se puede utilizar este m\xe9todo."))}m.isMDXComponent=!0}}]);